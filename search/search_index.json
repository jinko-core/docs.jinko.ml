{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"jinko programming documentation Welcome to the documentation regarding the jinko programming language ! You can find information on how to use the language as well as documentation about the standard library. A development guide is also included for contributors. Sections Language documentation : How to program in jinko Standard library : Developer documentation for the standard library Writeups : Blogposts or design documents regarding jinko's implementation Contact Matrix server Feel free to ask about anything on our #dev and #off-topic channels. We're aware that the documentation might not be in a clear enough state for new programmers! Links Repository GitHub organization","title":"`jinko` programming documentation"},{"location":"#jinko-programming-documentation","text":"Welcome to the documentation regarding the jinko programming language ! You can find information on how to use the language as well as documentation about the standard library. A development guide is also included for contributors.","title":"jinko programming documentation"},{"location":"#sections","text":"Language documentation : How to program in jinko Standard library : Developer documentation for the standard library Writeups : Blogposts or design documents regarding jinko's implementation","title":"Sections"},{"location":"#contact","text":"Matrix server Feel free to ask about anything on our #dev and #off-topic channels. We're aware that the documentation might not be in a clear enough state for new programmers!","title":"Contact"},{"location":"#links","text":"Repository GitHub organization","title":"Links"},{"location":"language/","text":"The jinko programming language jinko is an interpreted strongly and statically typed programming language. It relies on a strong typechecker and a low amount of concepts in order to keep scripts simple and correct. The goal of jinko is to stay simple: The language specification should stay tiny, with few keywords and few builtins. If possible, a lot of the functionality should be baked-in the standard library: This helps in having multiple possible implementations, which could implement a complete language by respecting a small specification. The standard library should rely on the type system as much as possible. This chapter contains information regarding how to program in jinko . Inside, you will find out how the type-system works, how it compares to other languages, how to do conditionals, for loops, or any other language construct. Keep in mind that jinko is still being developed: If something in this chapter is not clear enough or seems invalid, please let us know via a github issue or on our matrix chat . Types Variables Functions Conditionals Loops Blocks Code inclusion","title":"The jinko programming language"},{"location":"language/#the-jinko-programming-language","text":"jinko is an interpreted strongly and statically typed programming language. It relies on a strong typechecker and a low amount of concepts in order to keep scripts simple and correct. The goal of jinko is to stay simple: The language specification should stay tiny, with few keywords and few builtins. If possible, a lot of the functionality should be baked-in the standard library: This helps in having multiple possible implementations, which could implement a complete language by respecting a small specification. The standard library should rely on the type system as much as possible. This chapter contains information regarding how to program in jinko . Inside, you will find out how the type-system works, how it compares to other languages, how to do conditionals, for loops, or any other language construct. Keep in mind that jinko is still being developed: If something in this chapter is not clear enough or seems invalid, please let us know via a github issue or on our matrix chat . Types Variables Functions Conditionals Loops Blocks Code inclusion","title":"The jinko programming language"},{"location":"language/variables/","text":"Declaring variables a = 15 ; Type hinting a : int = 15 ; Using variables","title":"Variables"},{"location":"language/variables/#declaring-variables","text":"a = 15 ;","title":"Declaring variables"},{"location":"language/variables/#type-hinting","text":"a : int = 15 ;","title":"Type hinting"},{"location":"language/variables/#using-variables","text":"","title":"Using variables"},{"location":"language/types/0_builtin_types/","text":"Built-in types 4 types are baked in the interpreter: bool , int , float , string and char . Each of these types has associated functions, which can be found in the standard library. int int represents all sorts of signed integers. It is 64-bits wide, and can contain values from -9 223 372 036 854 775 808 to 9 223 372 036 854 775 807 . float float is a double-precision floating point number, similar to C's double or Rust's f64 . bool At the moment, booleans are still builtin types with two associated keywords: true and false . Thanks to this chapter, you'll soon see why we plan on replacing it with the following in our standard library. type true ; type false ; type bool ( true | false ); char char s are simple UTF-8 characters. string In jinko , strings are not simply arrays of characters, at least for now. We rely on Rust's String implementation in order to have the string type. This is subject to change, and will obviously be different once the interpreter is self-hosted.","title":"Built-in types"},{"location":"language/types/0_builtin_types/#built-in-types","text":"4 types are baked in the interpreter: bool , int , float , string and char . Each of these types has associated functions, which can be found in the standard library. int int represents all sorts of signed integers. It is 64-bits wide, and can contain values from -9 223 372 036 854 775 808 to 9 223 372 036 854 775 807 . float float is a double-precision floating point number, similar to C's double or Rust's f64 . bool At the moment, booleans are still builtin types with two associated keywords: true and false . Thanks to this chapter, you'll soon see why we plan on replacing it with the following in our standard library. type true ; type false ; type bool ( true | false ); char char s are simple UTF-8 characters. string In jinko , strings are not simply arrays of characters, at least for now. We rely on Rust's String implementation in order to have the string type. This is subject to change, and will obviously be different once the interpreter is self-hosted.","title":"Built-in types"},{"location":"language/types/1_custom_types/","text":"Custom types in jinko Declaration Instantiation","title":"Custom types in jinko"},{"location":"language/types/1_custom_types/#custom-types-in-jinko","text":"","title":"Custom types in jinko"},{"location":"language/types/1_custom_types/#declaration","text":"","title":"Declaration"},{"location":"language/types/1_custom_types/#instantiation","text":"","title":"Instantiation"},{"location":"language/types/2_contract/","text":"Type obligations When defining a custom type , you may wish for your users to respect certain obligations. Say for example, that you wish to only deal with even numbers. You would define an Even type, containing its associated integer. type Even ( value : int ); This isn't really useful, since you're able to do the following: two = Even ( value : 3 ); One solution to this would be to hide the instantiation of this type behind a function, and telling the user to be very careful and only call this function to create a new even number: func even ( from : int ) -> Maybe [ Even ] { if from . mod ( 2 ) == 0 { Even ( value : from ) } else { Nothing } } which forces your users to make sure they've received a correct Even and not an instance of Nothing . Since this behavior is extremely useful (ranged integers, specific values out of multiple possibilities, safety checks...), jinko offers a keyword to help define conditions that users must uphold when instantiating types. The standard library uses those type obligations in order to make calls to foreign functions safer: For example, when wrapping the standard C library, you will often face two situations when dealing with pointers: A null pointer is a valid value, and will be checked for ( write(3) ) A null pointer is invalid, and will not be checked for: The function might crash ( qsort(3) ) You can easily represent these two types of pointers in jinko : One is simply a pointer, and the other a non-null pointer. These are not novel concepts: They've been in various programming languages. However, jinko 's type system helps in making sure that a Pointer is never given to a function expecting a NonNullPointer , while still easily allowing you to convert a NonNullPointer into a Pointer . Defining type obligations You can define a type obligation by adding the with keyword to your type declaration: type Even ( value : int ) with value . mod ( 2 ) == 0 ; The syntax is as follows: ' type ' < name > '(' < fields > ')' ' with ' < boolean_expr > ';' A boolean expression can be any jinko expression: It will be typechecked to make sure that it returns a boolean. This means that you can have multiple checks on a single type: type PositiveEven ( value : int ) with value . mod ( 2 ) == 0 && value > 0 ; // or slightly more verbose type PositiveEven ( value : int ) with { mod_check = value . mod ( 2 ) == 0 ; pos_check = value > 0 ; mod_check && pos_check } Instantiating types with type obligations When creating such a type instance, it is important to note to the user that failure might occur. This is why instantiating those values will not directly return the type T , but T wrapped in a Maybe : a : Even = Even ( value : 2 ); // type error! // `a` is actually of the type `Maybe[Even]` We must handle the optional type to make sure that we deal with the failure case appropriately: a0 : Even = Even ( value : 2 ). unpack (); // if we know it cannot fail a1 : Even = Even ( value : 2 ). try (); // to propagate the error to the caller In the case that the condition fails, an instance of Nothing will be returned. assert ( Even ( value : 3 ). is_nothing ()) // true Making our safe FFI pointer types As explained above, the problem is as follows: Some pointers are allowed to be null pointers, while some pointers cannot . Let's take the following C example, which sorts an array of integers: #include <assert.h> #include <stdbool.h> #include <stdio.h> #include <stdlib.h> int icmp ( const void * l_v , const void * r_v ) { int l = ( int )( unsigned long ) l_v ; int r = ( int )( unsigned long ) r_v ; return r > l ? 1 : r < l ? -1 : 0 ; } int main ( void ) { int * ptr = NULL ; int array [ 5 ] = { 0 , 1 , 2 , 3 , 4 }; qsort ( array , 5 , sizeof ( int ), icmp ); for ( size_t i = 0 ; i < 5 ; i ++ ) printf ( \"array[%lu] = %d \\n \" , i , array [ i ]); // No comparison function here qsort ( array , 5 , sizeof ( int ), NULL ); return 0 ; } In the case that we forget to give a valid comparison function to qsort , the program will crash. When wrapping the qsort function in jinko , we might thus want to mark the last argument of the function as a NonNullPointer : link_with ( \"libc.so.6\" ); ext func qsort ( base : NonNullPointer , nmemb : int , size : int , cmp : NonNullPointer ); This will prevent jinko code to ever pass a NULL pointer to the qsort function. type RawPointer ( raw_value : int ); // ... type NonNullPointer ( ptr : RawPointer ) with ptr . raw_value != 0 ; Since we may want to give NonNullPointer s to functions that expect a regular, nullable Pointer , we can use multi-types to defined the Pointer type: type Pointer ( ptr : NonNullPointer | RawPointer ); Any value of type Pointer will thus be able to be created by upcasting a NonNullPointer or a RawPointer .","title":"Type obligations"},{"location":"language/types/2_contract/#type-obligations","text":"When defining a custom type , you may wish for your users to respect certain obligations. Say for example, that you wish to only deal with even numbers. You would define an Even type, containing its associated integer. type Even ( value : int ); This isn't really useful, since you're able to do the following: two = Even ( value : 3 ); One solution to this would be to hide the instantiation of this type behind a function, and telling the user to be very careful and only call this function to create a new even number: func even ( from : int ) -> Maybe [ Even ] { if from . mod ( 2 ) == 0 { Even ( value : from ) } else { Nothing } } which forces your users to make sure they've received a correct Even and not an instance of Nothing . Since this behavior is extremely useful (ranged integers, specific values out of multiple possibilities, safety checks...), jinko offers a keyword to help define conditions that users must uphold when instantiating types. The standard library uses those type obligations in order to make calls to foreign functions safer: For example, when wrapping the standard C library, you will often face two situations when dealing with pointers: A null pointer is a valid value, and will be checked for ( write(3) ) A null pointer is invalid, and will not be checked for: The function might crash ( qsort(3) ) You can easily represent these two types of pointers in jinko : One is simply a pointer, and the other a non-null pointer. These are not novel concepts: They've been in various programming languages. However, jinko 's type system helps in making sure that a Pointer is never given to a function expecting a NonNullPointer , while still easily allowing you to convert a NonNullPointer into a Pointer .","title":"Type obligations"},{"location":"language/types/2_contract/#defining-type-obligations","text":"You can define a type obligation by adding the with keyword to your type declaration: type Even ( value : int ) with value . mod ( 2 ) == 0 ; The syntax is as follows: ' type ' < name > '(' < fields > ')' ' with ' < boolean_expr > ';' A boolean expression can be any jinko expression: It will be typechecked to make sure that it returns a boolean. This means that you can have multiple checks on a single type: type PositiveEven ( value : int ) with value . mod ( 2 ) == 0 && value > 0 ; // or slightly more verbose type PositiveEven ( value : int ) with { mod_check = value . mod ( 2 ) == 0 ; pos_check = value > 0 ; mod_check && pos_check }","title":"Defining type obligations"},{"location":"language/types/2_contract/#instantiating-types-with-type-obligations","text":"When creating such a type instance, it is important to note to the user that failure might occur. This is why instantiating those values will not directly return the type T , but T wrapped in a Maybe : a : Even = Even ( value : 2 ); // type error! // `a` is actually of the type `Maybe[Even]` We must handle the optional type to make sure that we deal with the failure case appropriately: a0 : Even = Even ( value : 2 ). unpack (); // if we know it cannot fail a1 : Even = Even ( value : 2 ). try (); // to propagate the error to the caller In the case that the condition fails, an instance of Nothing will be returned. assert ( Even ( value : 3 ). is_nothing ()) // true","title":"Instantiating types with type obligations"},{"location":"language/types/2_contract/#making-our-safe-ffi-pointer-types","text":"As explained above, the problem is as follows: Some pointers are allowed to be null pointers, while some pointers cannot . Let's take the following C example, which sorts an array of integers: #include <assert.h> #include <stdbool.h> #include <stdio.h> #include <stdlib.h> int icmp ( const void * l_v , const void * r_v ) { int l = ( int )( unsigned long ) l_v ; int r = ( int )( unsigned long ) r_v ; return r > l ? 1 : r < l ? -1 : 0 ; } int main ( void ) { int * ptr = NULL ; int array [ 5 ] = { 0 , 1 , 2 , 3 , 4 }; qsort ( array , 5 , sizeof ( int ), icmp ); for ( size_t i = 0 ; i < 5 ; i ++ ) printf ( \"array[%lu] = %d \\n \" , i , array [ i ]); // No comparison function here qsort ( array , 5 , sizeof ( int ), NULL ); return 0 ; } In the case that we forget to give a valid comparison function to qsort , the program will crash. When wrapping the qsort function in jinko , we might thus want to mark the last argument of the function as a NonNullPointer : link_with ( \"libc.so.6\" ); ext func qsort ( base : NonNullPointer , nmemb : int , size : int , cmp : NonNullPointer ); This will prevent jinko code to ever pass a NULL pointer to the qsort function. type RawPointer ( raw_value : int ); // ... type NonNullPointer ( ptr : RawPointer ) with ptr . raw_value != 0 ; Since we may want to give NonNullPointer s to functions that expect a regular, nullable Pointer , we can use multi-types to defined the Pointer type: type Pointer ( ptr : NonNullPointer | RawPointer ); Any value of type Pointer will thus be able to be created by upcasting a NonNullPointer or a RawPointer .","title":"Making our safe FFI pointer types"},{"location":"language/types/multi_types/","text":"Multi types Defining multi-types Upcasting","title":"Multi types"},{"location":"language/types/multi_types/#multi-types","text":"","title":"Multi types"},{"location":"language/types/multi_types/#defining-multi-types","text":"","title":"Defining multi-types"},{"location":"language/types/multi_types/#upcasting","text":"","title":"Upcasting"},{"location":"standard-library/","text":"Documentation The documentation is also available inside the stdlib 's source code. This is a rendered version which contains the same exact content. stdlib modules","title":"Documentation"},{"location":"standard-library/#documentation","text":"The documentation is also available inside the stdlib 's source code. This is a rendered version which contains the same exact content.","title":"Documentation"},{"location":"standard-library/#stdlib-modules","text":"","title":"stdlib modules"},{"location":"writeups/","text":"Writeups index Design documents Language overall design considerations Error handling design considerations Generics expansion Desugaring jinko's multi-types Error handling inside the interpreter","title":"Writeups index"},{"location":"writeups/#writeups-index","text":"","title":"Writeups index"},{"location":"writeups/#design-documents","text":"Language overall design considerations Error handling design considerations Generics expansion Desugaring jinko's multi-types Error handling inside the interpreter","title":"Design documents"},{"location":"writeups/0-design/","text":"Design This document describes some of the choices made when developing jinko, as well as some implementation choices Stmts and Exprs There are two types of instructions in jinko: Those returning the equivalent of void , or {} , such as a variable assignation: x = 12 ; // Returns \"void\" func void_func () { // Returns nothing } void_func (); // Thus a statement as well And those returning any other type, which must not be ignored. For example, constant expressions or non-void function calls: func return_x ( int : x ) -> int { x // Returns an integer. Notice the lack of semicolon } func return_func ( int : x ) -> func ( int ) -> int { l = func lambda ( int : x ) -> int { x + 1 }; l } // This returns a lambda taking an int as argument and returning an int Statements are void, while Expressions return something. You cannot ignore a non-void return value. Unit tests Embedding unit testing in a language relies on using an \"attribute-like\" syntax. For example, in Java you can do the following by using a library, JUnit, which itself uses attributes (@ syntax). @Test public void something_something_factory_bean_sprout () { assertEquals ( something (), something_else ()); } In rust, attributes (or tags) use the #[syntax]. Unit tests are embedded directly into the language without the need for external libraries. #[test] fn something_in_rust () { assert_eq! ( something (), something_else ()); } In jinko, test functions require no attribute (not that it's any better than using an attribute, it's just simpler for the interpreter). test something_but_in_jinko () { assert_eq ( something (), something_else ()); } Mocking is done similarly, by using the mock keyword /* This will mock the function something() */ mock something () { /* Mocking */ } Choosing between func and fn jinko uses three keywords to define \"functions\": * test which are unit tests * mock which are function mocks * func which is for functions and procedures (Procedures return Nothing , while Functions return Something ) func was chosen over fn because this way, it looks pretty when next to a test or a mock :) The Instruction struct Instructions are a central part of Jinko. A jinko program is composed of instructions and functions, which themselves are instructions. Instructions can be either Statements or Expressions x = 12 ; // Stmt x // Expr -> This jinko code simply assigns a variable x and returns it. If you execute it, the exit-code will be the value assigned to x . In that case, 12 An instruction needs to contain \"spacial\" information (Where is it in the file ? In what file ?), source (the actual source code, for errors), and a Statement or an Expression to execute. Importing other source files Since jinko scripts are simple scripts a la Python, where there is no main functions, importing simply works by \"copy/pasting\" other source files. There is no distinction between headers and source files, so it's a bit different from C's preprocessor for example. However, the syntax is similar incl other_script ; /* Functions, Variables in other_script are imported. They're now named other_script::<function_name>, other_script::<var_name> and so on */ There is no way to remove the usage of <source_name>:: . This is the cause of some programming issues in C++, C# and other languages with similar features. You can only import an external source once per program. This way, no circular dependencies are created. To separate sources with the same name, for example from multiple directories, you can use the as syntax // Wrong incl dir0 :: source0 ; incl dir1 :: source0 ; /* Both sources would have the same name. This is an error */ // Good incl dir0 :: source0 as dir0_source0 ; incl dir1 :: source0 as dir1_source0 ; /* Now, dir0::source0 functions are named dir0_source0::<function_name> and so on */ For now, you can also include directories: /* | _ main.jk | _ std/ | _ lib.jk // includes option.jk, result.jk maybe, etc | _ option.jk | _ result.jk */ ``` rust incl std // Actually includes std/lib.jk I'm not entirely happy with this design yet. It's obviously open to discussion and changes. Garbage collection Memory allocation and collection is done via reference counting. This implies lower stress on the hardware used to run the program, and is easier to implement, thus keeping jinko simpler. However, this causes issues when an instance references itself, thus creating memory leaks. FFI The idea is to mark functions from external shared libraries with the ext keyword. ext func add ( lhs : int , rhs : int ) -> int ; // This function isn't defined in jinko Calling add() will actually make a call into a native-code function, for example one written in Rust, C or C++. Adjustments need to be done on the native side of things in order to allow name resolution Nullable types In Rust, types are not nullable. There is no way (in the safe subset of the language at least) to return NULL as a value. However, the Option type exists: You can either return Some(value) or None in case something went wrong. You also have to handle both cases when using those Option types. In languages such as Zig (I think) or Dart (soon), some types can be \"nullable\". By annotating the type with a question mark, you can indicate that the value might be null. For example, String needs to be a valid string, but String? can be a valid string or NULL. These two approaches do not exactly serve the same purpose. However, they are useful when it comes to error handling, as well as the possibility of not having something. In C, you are constrained to use NULL. Every pointer is \"nullable\", and therefore you always have to check for NULL. In Dart and Zig, you only have to check for NULL if the type is nullable. In Rust, you have to check your option types or unwrap() on them, which will cause a panic in case of a None (a bit equivalent to segfaulting on NULL, but less sneaky and way less vulnerable). While these two approaches both have advantages and inconvenient, the Rust approach is, in my opinion for Jinko, significantly better for a simple reason: Even if Options are part of the standard library and \"included\" by default, they do not rely on some obscure compiler magic: They are just a type. Therefore, they are being understood by the compiler as just a type. And I think that keeping jinko simple also means keeping the interpreter simple. Therefore, I think that simply using Option s (or some other nomenclature) would be best. The interpreter The jinko interpreter should keep track of variables and functions. Therefore, at least two hashmaps are required, one for variables and one for functions. Each of these elements need to have a unique name to identify them. Structure Types Allowing user defined types makes for cleaner as well as stricter code. One thing that jinko really has to focus about is \"zero-cost types\", as in custom types that englobe a single, other type without penalty. In the mean time, the interpreter should also focus on simple parsing and fonctionality. Let's split this section in two: Simple type parsing In order to keep the parsing simple, as much code as possible should be reused. At this point, the parser is already around 1500 lines big, and that's big enough. Types declarations are similar to function declarations: They have a name, take arguments. Type instantiations, however are quite different. Let's examine a custom types in C and its instantiation: struct custom_type { int int_value ; char some_character ; float f ; }; // And to initialize it, one way is to do the following struct custom_type value = { . int_value = 4 , . char = 'J' , . float = 27.07 }; This is similar to creating and calling a function, only that the syntax differs. I believe jinko could keep the same syntax for both custom types and custom functions, as they aim to achieve the same \"kind\" of result: A custom, user-made behavior that produces cleaner and more readable code. Thus, the following syntax should be adopted at first: // This is similar to a function declaration, without a block and with a ``type`` instead of ``fn`` type CustomType ( int_value : int , some_character : char , f : float ); // Let's create one value = CustomType ( int_value : 4 , some_character : ' J ' , f : 27.07 ); If your types get too big, then just like function definitions, multilines are supported. type CustomType ( int_value : int , some_character : char , f : float , ); The only difference between a function definition and a type definition is the keyword: type or func and no block of code for the type instantiation. Type instantiations use the : token to associate a value with a field, while function calls do not use any token. For optional/named arguments, function calls use the = token Methods and functions in Jinko Let's say you define your custom type in C. If you do \"object oriented C\", you'll probably end up with the following: /* Simple linked list node */ struct ll { int value ; struct ll * next ; }; /* Create a new node */ struct ll * ll_new ( int value , struct ll * next ); /* Destroy a previously created node */ void ll_del ( struct ll * head ); /* Get the next node */ struct ll * ll_next ( struct ll * node ); /* Get the value from the node */ int ll_value ( struct ll * node ); /* Push some node to the list */ void ll_push ( struct ll * node , struct ll * next ); /* Implementation is not important */ int main ( void ) { // Create our head struct ll * last = ll_new ( 3 , NULL ); struct ll * mid = ll_new ( 2 , last ); struct ll * head = ll_new ( 1 , mid ); struct ll * rand = ll_new ( 67 , NULL ); ll_push ( head , rand ); // Make sure the positions and values are correct assert ( ll_value ( ll_next ( head )) == 2 ); // We're done with the list ll_del ( head ); } The \"object oriented\" approach does not really work in C, and is cumbersome. Compare it to any actual OOP language, where we could do head.del() , or head.next().value() . However, the object oriented approach brings in a lot of complexity, too much for jinko. A struct model, in a C way should be prefered. But that doesn't mean we can't add some syntactic sugar to it. Let's consider a custom type with its \"methods\" and a simple function. // There's already a \"default constructor\", so we don't need to define new(). Also, there // is no NULL in jinko type LinkedList ( value : int , next : Option < LinkedList > ); func del ( head : LinkedList ) { /* Walk the whole list, deleting stuff as it comes */ } func value ( node : LinkedList ) -> int { node . value } func next ( node : LinkedList ) -> LinkedList { node . next } func push ( node : LinkedList , next : LinkedList ) { /* Some code to add next to the end of the list or whatever */ } last = LinkedList ( 3 , None ); mid = LinkedList ( 2 , Some ( last )); head = LinkedList ( 1 , Some ( mid )); head . push ( LinkedList ( 67 , None )); /* Or ... */ push ( head , LinkedList ( 67 , None )); assert_eq ( head . next (). value (), 2 ); /* Or ... */ assert_eq ( value ( next ( head )), 2 ); /* We're done with the list */ head . del (); Both calling methods are valid. In the end, to keep things simple, the first argument will always act similarly to self in Rust, or this in most OOP languages. This also means that the following is possible func add ( a : int , b : int ) -> { a + b } 12. add ( 15 ); add ( 12 , 15 ); So the concept of methods doesn't really exist in Jinko. The calling method is just syntactic sugar over regular function calling. No-cost custom types Let's say you're using an API, and using some complex custom made function. For example, add_friend , which takes a last name, a first name, and a nickname. Let's say you're not using an IDE or a language server: You remember the function name, but not the order of the arguments: Is it add_friend(first_name, name, nickname) ? add_friend(nickname, first_name, name) ? If the API was designed by a japanese coder, maybe it's add_friend(name, first_name, nickname) ? There is no way to know without checking the documentation. Now, this is good, since it forces you to check the documentation. But we can also enforce type safety and data safety through the interpreter. // The friend type, that already existed type Friend ( /* Some values */ ); // Define three \"custom\" types type Name ( the_name : str ); type FirstName ( value : str ); type Nickname ( hidden : str ); // And define the API function like so: func add_friend ( name : Name , f_name : FirstName , n_name : Nickname ) -> Friend { /* Some code */ } Generics Generics rely on the use of brackets so that the parser can easily differentiate between a generic use/declaration ( A<T> ) versus a variable comparison ( A < T ) without any sort of lookahead. Thus, the following in C++ std :: vector < std :: unordered_map < std :: string , int >> map = ...; would become in jinko map : Vec [ Map [ string , int ]] = .. .; Likewise, the following Rust code fn takes_result ( r : Result < String , SomeErrorType > ) {} becomes func takes_result ( r : Result [ string , SomeErrorType ]) {} This syntax is similar to scala's generics, which are quite nice to use. Generics, just like function parameters, should be able to take a default value, which could be specified by name. type BaseError ( inner : string ); type Ok [ T ]( T ); type Err [ T ]( T ); type Result [ T = void , E = BaseError ]( Ok [ T ], Err [ E ]); // We can avoid typing `Result` by using type promotion but w/e, this is for // the example's sake ok_0 = Result [ int ]( Ok ( 15 )); // E defaults to BaseError ok_1 = Result [ int , string ]( Ok ( 15 )); ok_2 = Result [ int , string ]( Err ( \"oops\" )); ok_4 = Result [ T = int , string ]( Err ( \"oops\" )); ok_5 = Result [ T = int , E = string ]( Err ( \"oops\" )); ok_6 = Result [ E = bool ]( Err ( false )); // T defaults to void","title":"Design"},{"location":"writeups/0-design/#design","text":"This document describes some of the choices made when developing jinko, as well as some implementation choices","title":"Design"},{"location":"writeups/0-design/#stmts-and-exprs","text":"There are two types of instructions in jinko: Those returning the equivalent of void , or {} , such as a variable assignation: x = 12 ; // Returns \"void\" func void_func () { // Returns nothing } void_func (); // Thus a statement as well And those returning any other type, which must not be ignored. For example, constant expressions or non-void function calls: func return_x ( int : x ) -> int { x // Returns an integer. Notice the lack of semicolon } func return_func ( int : x ) -> func ( int ) -> int { l = func lambda ( int : x ) -> int { x + 1 }; l } // This returns a lambda taking an int as argument and returning an int Statements are void, while Expressions return something. You cannot ignore a non-void return value.","title":"Stmts and Exprs"},{"location":"writeups/0-design/#unit-tests","text":"Embedding unit testing in a language relies on using an \"attribute-like\" syntax. For example, in Java you can do the following by using a library, JUnit, which itself uses attributes (@ syntax). @Test public void something_something_factory_bean_sprout () { assertEquals ( something (), something_else ()); } In rust, attributes (or tags) use the #[syntax]. Unit tests are embedded directly into the language without the need for external libraries. #[test] fn something_in_rust () { assert_eq! ( something (), something_else ()); } In jinko, test functions require no attribute (not that it's any better than using an attribute, it's just simpler for the interpreter). test something_but_in_jinko () { assert_eq ( something (), something_else ()); } Mocking is done similarly, by using the mock keyword /* This will mock the function something() */ mock something () { /* Mocking */ }","title":"Unit tests"},{"location":"writeups/0-design/#choosing-between-func-and-fn","text":"jinko uses three keywords to define \"functions\": * test which are unit tests * mock which are function mocks * func which is for functions and procedures (Procedures return Nothing , while Functions return Something ) func was chosen over fn because this way, it looks pretty when next to a test or a mock :)","title":"Choosing between func and fn"},{"location":"writeups/0-design/#the-instruction-struct","text":"Instructions are a central part of Jinko. A jinko program is composed of instructions and functions, which themselves are instructions. Instructions can be either Statements or Expressions x = 12 ; // Stmt x // Expr -> This jinko code simply assigns a variable x and returns it. If you execute it, the exit-code will be the value assigned to x . In that case, 12 An instruction needs to contain \"spacial\" information (Where is it in the file ? In what file ?), source (the actual source code, for errors), and a Statement or an Expression to execute.","title":"The Instruction struct"},{"location":"writeups/0-design/#importing-other-source-files","text":"Since jinko scripts are simple scripts a la Python, where there is no main functions, importing simply works by \"copy/pasting\" other source files. There is no distinction between headers and source files, so it's a bit different from C's preprocessor for example. However, the syntax is similar incl other_script ; /* Functions, Variables in other_script are imported. They're now named other_script::<function_name>, other_script::<var_name> and so on */ There is no way to remove the usage of <source_name>:: . This is the cause of some programming issues in C++, C# and other languages with similar features. You can only import an external source once per program. This way, no circular dependencies are created. To separate sources with the same name, for example from multiple directories, you can use the as syntax // Wrong incl dir0 :: source0 ; incl dir1 :: source0 ; /* Both sources would have the same name. This is an error */ // Good incl dir0 :: source0 as dir0_source0 ; incl dir1 :: source0 as dir1_source0 ; /* Now, dir0::source0 functions are named dir0_source0::<function_name> and so on */ For now, you can also include directories: /* | _ main.jk | _ std/ | _ lib.jk // includes option.jk, result.jk maybe, etc | _ option.jk | _ result.jk */ ``` rust incl std // Actually includes std/lib.jk I'm not entirely happy with this design yet. It's obviously open to discussion and changes.","title":"Importing other source files"},{"location":"writeups/0-design/#garbage-collection","text":"Memory allocation and collection is done via reference counting. This implies lower stress on the hardware used to run the program, and is easier to implement, thus keeping jinko simpler. However, this causes issues when an instance references itself, thus creating memory leaks.","title":"Garbage collection"},{"location":"writeups/0-design/#ffi","text":"The idea is to mark functions from external shared libraries with the ext keyword. ext func add ( lhs : int , rhs : int ) -> int ; // This function isn't defined in jinko Calling add() will actually make a call into a native-code function, for example one written in Rust, C or C++. Adjustments need to be done on the native side of things in order to allow name resolution","title":"FFI"},{"location":"writeups/0-design/#nullable-types","text":"In Rust, types are not nullable. There is no way (in the safe subset of the language at least) to return NULL as a value. However, the Option type exists: You can either return Some(value) or None in case something went wrong. You also have to handle both cases when using those Option types. In languages such as Zig (I think) or Dart (soon), some types can be \"nullable\". By annotating the type with a question mark, you can indicate that the value might be null. For example, String needs to be a valid string, but String? can be a valid string or NULL. These two approaches do not exactly serve the same purpose. However, they are useful when it comes to error handling, as well as the possibility of not having something. In C, you are constrained to use NULL. Every pointer is \"nullable\", and therefore you always have to check for NULL. In Dart and Zig, you only have to check for NULL if the type is nullable. In Rust, you have to check your option types or unwrap() on them, which will cause a panic in case of a None (a bit equivalent to segfaulting on NULL, but less sneaky and way less vulnerable). While these two approaches both have advantages and inconvenient, the Rust approach is, in my opinion for Jinko, significantly better for a simple reason: Even if Options are part of the standard library and \"included\" by default, they do not rely on some obscure compiler magic: They are just a type. Therefore, they are being understood by the compiler as just a type. And I think that keeping jinko simple also means keeping the interpreter simple. Therefore, I think that simply using Option s (or some other nomenclature) would be best.","title":"Nullable types"},{"location":"writeups/0-design/#the-interpreter","text":"The jinko interpreter should keep track of variables and functions. Therefore, at least two hashmaps are required, one for variables and one for functions. Each of these elements need to have a unique name to identify them.","title":"The interpreter"},{"location":"writeups/0-design/#structure-types","text":"Allowing user defined types makes for cleaner as well as stricter code. One thing that jinko really has to focus about is \"zero-cost types\", as in custom types that englobe a single, other type without penalty. In the mean time, the interpreter should also focus on simple parsing and fonctionality. Let's split this section in two:","title":"Structure Types"},{"location":"writeups/0-design/#simple-type-parsing","text":"In order to keep the parsing simple, as much code as possible should be reused. At this point, the parser is already around 1500 lines big, and that's big enough. Types declarations are similar to function declarations: They have a name, take arguments. Type instantiations, however are quite different. Let's examine a custom types in C and its instantiation: struct custom_type { int int_value ; char some_character ; float f ; }; // And to initialize it, one way is to do the following struct custom_type value = { . int_value = 4 , . char = 'J' , . float = 27.07 }; This is similar to creating and calling a function, only that the syntax differs. I believe jinko could keep the same syntax for both custom types and custom functions, as they aim to achieve the same \"kind\" of result: A custom, user-made behavior that produces cleaner and more readable code. Thus, the following syntax should be adopted at first: // This is similar to a function declaration, without a block and with a ``type`` instead of ``fn`` type CustomType ( int_value : int , some_character : char , f : float ); // Let's create one value = CustomType ( int_value : 4 , some_character : ' J ' , f : 27.07 ); If your types get too big, then just like function definitions, multilines are supported. type CustomType ( int_value : int , some_character : char , f : float , ); The only difference between a function definition and a type definition is the keyword: type or func and no block of code for the type instantiation. Type instantiations use the : token to associate a value with a field, while function calls do not use any token. For optional/named arguments, function calls use the = token","title":"Simple type parsing"},{"location":"writeups/0-design/#methods-and-functions-in-jinko","text":"Let's say you define your custom type in C. If you do \"object oriented C\", you'll probably end up with the following: /* Simple linked list node */ struct ll { int value ; struct ll * next ; }; /* Create a new node */ struct ll * ll_new ( int value , struct ll * next ); /* Destroy a previously created node */ void ll_del ( struct ll * head ); /* Get the next node */ struct ll * ll_next ( struct ll * node ); /* Get the value from the node */ int ll_value ( struct ll * node ); /* Push some node to the list */ void ll_push ( struct ll * node , struct ll * next ); /* Implementation is not important */ int main ( void ) { // Create our head struct ll * last = ll_new ( 3 , NULL ); struct ll * mid = ll_new ( 2 , last ); struct ll * head = ll_new ( 1 , mid ); struct ll * rand = ll_new ( 67 , NULL ); ll_push ( head , rand ); // Make sure the positions and values are correct assert ( ll_value ( ll_next ( head )) == 2 ); // We're done with the list ll_del ( head ); } The \"object oriented\" approach does not really work in C, and is cumbersome. Compare it to any actual OOP language, where we could do head.del() , or head.next().value() . However, the object oriented approach brings in a lot of complexity, too much for jinko. A struct model, in a C way should be prefered. But that doesn't mean we can't add some syntactic sugar to it. Let's consider a custom type with its \"methods\" and a simple function. // There's already a \"default constructor\", so we don't need to define new(). Also, there // is no NULL in jinko type LinkedList ( value : int , next : Option < LinkedList > ); func del ( head : LinkedList ) { /* Walk the whole list, deleting stuff as it comes */ } func value ( node : LinkedList ) -> int { node . value } func next ( node : LinkedList ) -> LinkedList { node . next } func push ( node : LinkedList , next : LinkedList ) { /* Some code to add next to the end of the list or whatever */ } last = LinkedList ( 3 , None ); mid = LinkedList ( 2 , Some ( last )); head = LinkedList ( 1 , Some ( mid )); head . push ( LinkedList ( 67 , None )); /* Or ... */ push ( head , LinkedList ( 67 , None )); assert_eq ( head . next (). value (), 2 ); /* Or ... */ assert_eq ( value ( next ( head )), 2 ); /* We're done with the list */ head . del (); Both calling methods are valid. In the end, to keep things simple, the first argument will always act similarly to self in Rust, or this in most OOP languages. This also means that the following is possible func add ( a : int , b : int ) -> { a + b } 12. add ( 15 ); add ( 12 , 15 ); So the concept of methods doesn't really exist in Jinko. The calling method is just syntactic sugar over regular function calling.","title":"Methods and functions in Jinko"},{"location":"writeups/0-design/#no-cost-custom-types","text":"Let's say you're using an API, and using some complex custom made function. For example, add_friend , which takes a last name, a first name, and a nickname. Let's say you're not using an IDE or a language server: You remember the function name, but not the order of the arguments: Is it add_friend(first_name, name, nickname) ? add_friend(nickname, first_name, name) ? If the API was designed by a japanese coder, maybe it's add_friend(name, first_name, nickname) ? There is no way to know without checking the documentation. Now, this is good, since it forces you to check the documentation. But we can also enforce type safety and data safety through the interpreter. // The friend type, that already existed type Friend ( /* Some values */ ); // Define three \"custom\" types type Name ( the_name : str ); type FirstName ( value : str ); type Nickname ( hidden : str ); // And define the API function like so: func add_friend ( name : Name , f_name : FirstName , n_name : Nickname ) -> Friend { /* Some code */ }","title":"No-cost custom types"},{"location":"writeups/0-design/#generics","text":"Generics rely on the use of brackets so that the parser can easily differentiate between a generic use/declaration ( A<T> ) versus a variable comparison ( A < T ) without any sort of lookahead. Thus, the following in C++ std :: vector < std :: unordered_map < std :: string , int >> map = ...; would become in jinko map : Vec [ Map [ string , int ]] = .. .; Likewise, the following Rust code fn takes_result ( r : Result < String , SomeErrorType > ) {} becomes func takes_result ( r : Result [ string , SomeErrorType ]) {} This syntax is similar to scala's generics, which are quite nice to use. Generics, just like function parameters, should be able to take a default value, which could be specified by name. type BaseError ( inner : string ); type Ok [ T ]( T ); type Err [ T ]( T ); type Result [ T = void , E = BaseError ]( Ok [ T ], Err [ E ]); // We can avoid typing `Result` by using type promotion but w/e, this is for // the example's sake ok_0 = Result [ int ]( Ok ( 15 )); // E defaults to BaseError ok_1 = Result [ int , string ]( Ok ( 15 )); ok_2 = Result [ int , string ]( Err ( \"oops\" )); ok_4 = Result [ T = int , string ]( Err ( \"oops\" )); ok_5 = Result [ T = int , E = string ]( Err ( \"oops\" )); ok_6 = Result [ E = bool ]( Err ( false )); // T defaults to void","title":"Generics"},{"location":"writeups/1-error-handling/","text":"Error handling in jinko This document should not cover the usage of Maybe[T] as that has been previously established. The Error type type Error [ T = string ]( from : T ); /// The error type is generic, as long as the contained type //implements the `as_error()` method fn emit [ T ]( err : Error [ T ]) { println_err ( err . from . as_error ()) } // Specialization for the default implementation fn emit [ string ]( err : Error [ string ]) { println_err ( err . from ) } Without a Result type // We can use the default `string` type contained in an `Error` // Fails if a division by 0 is performed func div_can_fail ( lhs : int , rhs : int ) -> int | Error { if rhs == 0 { Error ( from : \"Attempting division by 0\" ) } else { lhs / rhs } } switch div_can_fail ( 165 , 0 ) { value : int => println ( \"Result is {value}, yipee\" ), e : Error => e . emit (), } // We can also use a complex type as the error's inner // type type DivError ; fn as_error ( err : DivError ) -> string { \"Division error\" } func div_can_fail2 ( lhs : int , rhs : int ) -> int | Error [ DivError ] { if rhs == 0 { Error ( from : DivError ) } else { lhs / rhs } } With a Result type type Result [ T , E = string ]( Ok [ T ] | Error [ E ]); // Using the default string as error type again func div_can_fail3 ( lhs : int , rhs : int ) -> Result [ int ] { if rhs == 0 { Error ( from : \"Attempting division by 0\" ) } else { Ok ( with : lhs / rhs ) } } switch div_can_fail ( 165 , 0 ) { value : Ok => println ( \"Result is {value.get()}, yipee\" ), e : Error => e . emit (), } Propagating the errors Since jinko currently does not have a concept of postfix operators, we will need to rely on interpreter magic to propagate errors properly. // Assuming we have the same Result type before func try [ T , E ]( result : Result [ T , E ]) -> T { switch result { ok : Ok => ok . get (), err : Error => Jinko . caller (). return_with ( err ), // return *from* the caller } } func faillible_fn () -> Result [ int , DivError ] { Ok ( with : 3 ); } func another_faillible_fn () -> Result [ int , DivError ] { Err ( from : DivError ); } func propagate_result () -> Result [ int , DivError ] { a = faillible_fn (). try (); // ^ Ok(int) ^ int b = another_faillible_fn (). try (); // ^ Err(...) // // this will cause a return from the current function: try's caller // This instruction will never be reached, since b will always // be an Err[] and cause an early return. If b was valid, we would otherwise // just have extracted the integer and computed an addition here Ok ( with : a + b ) }","title":"Error handling in jinko"},{"location":"writeups/1-error-handling/#error-handling-in-jinko","text":"This document should not cover the usage of Maybe[T] as that has been previously established.","title":"Error handling in jinko"},{"location":"writeups/1-error-handling/#the-error-type","text":"type Error [ T = string ]( from : T ); /// The error type is generic, as long as the contained type //implements the `as_error()` method fn emit [ T ]( err : Error [ T ]) { println_err ( err . from . as_error ()) } // Specialization for the default implementation fn emit [ string ]( err : Error [ string ]) { println_err ( err . from ) }","title":"The Error type"},{"location":"writeups/1-error-handling/#without-a-result-type","text":"// We can use the default `string` type contained in an `Error` // Fails if a division by 0 is performed func div_can_fail ( lhs : int , rhs : int ) -> int | Error { if rhs == 0 { Error ( from : \"Attempting division by 0\" ) } else { lhs / rhs } } switch div_can_fail ( 165 , 0 ) { value : int => println ( \"Result is {value}, yipee\" ), e : Error => e . emit (), } // We can also use a complex type as the error's inner // type type DivError ; fn as_error ( err : DivError ) -> string { \"Division error\" } func div_can_fail2 ( lhs : int , rhs : int ) -> int | Error [ DivError ] { if rhs == 0 { Error ( from : DivError ) } else { lhs / rhs } }","title":"Without a Result type"},{"location":"writeups/1-error-handling/#with-a-result-type","text":"type Result [ T , E = string ]( Ok [ T ] | Error [ E ]); // Using the default string as error type again func div_can_fail3 ( lhs : int , rhs : int ) -> Result [ int ] { if rhs == 0 { Error ( from : \"Attempting division by 0\" ) } else { Ok ( with : lhs / rhs ) } } switch div_can_fail ( 165 , 0 ) { value : Ok => println ( \"Result is {value.get()}, yipee\" ), e : Error => e . emit (), }","title":"With a Result type"},{"location":"writeups/1-error-handling/#propagating-the-errors","text":"Since jinko currently does not have a concept of postfix operators, we will need to rely on interpreter magic to propagate errors properly. // Assuming we have the same Result type before func try [ T , E ]( result : Result [ T , E ]) -> T { switch result { ok : Ok => ok . get (), err : Error => Jinko . caller (). return_with ( err ), // return *from* the caller } } func faillible_fn () -> Result [ int , DivError ] { Ok ( with : 3 ); } func another_faillible_fn () -> Result [ int , DivError ] { Err ( from : DivError ); } func propagate_result () -> Result [ int , DivError ] { a = faillible_fn (). try (); // ^ Ok(int) ^ int b = another_faillible_fn (). try (); // ^ Err(...) // // this will cause a return from the current function: try's caller // This instruction will never be reached, since b will always // be an Err[] and cause an early return. If b was valid, we would otherwise // just have extracted the integer and computed an addition here Ok ( with : a + b ) }","title":"Propagating the errors"},{"location":"writeups/2-generics/","text":"Canonicalization and generics in jinko Rules Each block is its own subgraph Each line of the graph corresponds to an instruction Each arrow is an assignment statements simply have their return value \"ignored\" in this representation _ -> stmt Function declaration syntax: <func_name> -> [ <arg> [, <arg>]* ] -> <ret_val> examples: println -> s -> , takes_nothing -> -> , return_value -> -> x macro: ( $f_name : ident -> $($arg : ident ), * -> $($ret_type : ident ) ? ) Function call syntax: <func_name> <- [ <arg> [, <arg>]* ] examples: println <- 'hey' , takes_nothing <- , return_value <- macro: ( $f_name : ident <- $($arg : ident ), * ) Example graph func f ( a : int , b : int ) -> int { print ( a ); a + b } flowchart TD; subgraph f[f -> a, b -> x]; direction LR; a --> a_init; b --> b_init; x --> f_block; subgraph f_block[f_block -> block_x] direction LR; _ --> print[print <- a] block_x --> add[add <- a, b] end end Problem Generating specialized function during generic expansion [1] causes specialized functions to be dropped when exiting the current typechecking scope. Specialized functions (i.e. expanded generics) need to be generated and put in the outermost scopemap in order to not get deleted when exiting the current scope. [1]: A generic function can be declared and will be expanded right after typechecking // Original code func quack [ D ]( instance : D ) -> string { instance . get_quack_str () } i_quack = 15. quack (); type Duck ; fn get_quack_str ( d : Duck ) -> string { \"quack\" } r_quack = Duck . quack (); // after typechecking func quack [ D ]( instance : D ) -> string { instance . get_quack_str () } i_quack = 15. quack (); // 15 <- int // We want quack[int](instance: int) -> string type Duck ; fn get_quack_str ( d : Duck ) -> string { \"quack\" } r_quack = Duck . quack (); // Duck <- Duck // We want quack[Duck](instance: Duck) -> string // specialization/monomorphization func quack [ D ]( instance : D ) -> string { instance . get_quack_str () } func quack + int ( instance : int ) -> string { instance . get_quack_str () } // type error func quack + Duck ( instance : Duck ) -> string { instance . get_quack_str () } // Okay! i_quack = quack [ int ]( 15 ); type Duck ; fn get_quack_str ( d : Duck ) -> string { \"quack\" } r_quack = quack [ Duck ]( Duck ); Sadly, this process happens during typechecking which contains a different scopemap from the execution context. What we can do is return a vector of generated nodes after the typechecking phase and insert those in the execution context. They however need proper canonicalization, which we'll discuss after. flowchart TD; subgraph entry direction LR; subgraph quack_gen[quack+D -> instance -> s]; direction LR; instance --> instance_init; s --> f_block subgraph f_block[quack_block+D -> block_s] direction LR; block_s --> call[get_quack_str <- instance] end end i_quack --> quack_15[quack <- 15]; duck --> duck_insantiation[#instantiate <- Duck]; r_quack --> quack_duck[quack <- duck]; end end result: flowchart TD; classDef specialized fill:#f9f,stroke:#333,stroke-width:4px; class quack_Duck specialized; class quack_int specialized; subgraph entry direction LR; subgraph quack_gen[quack+D -> instance -> s]; direction LR; instance --> instance_init; s --> f_block subgraph f_block[quack_block+D -> block_s] direction LR; block_s --> call[get_quack_str <- instance] end end subgraph quack_Duck[quack+Duck -> instance+Duck -> s+Duck]; direction LR; Duck_instance[instance+Duck] --> Duck_instance_init[instance+Duck_init]; Duck_s[s+Duck] --> q_Duck_block subgraph q_Duck_block[quack_block+Duck -> block_s+Duck] direction LR; Duck_block_s[block_s+Duck] --> Duck_call[get_quack_str <- instance+Duck] end end subgraph quack_int[quack+int -> instance+int -> s+int]; direction LR; int_instance[instance+int] --> int_instance_init[instance+int_init]; int_s[s+int] --> q_int_block subgraph q_int_block[quack_block+int -> block_s+int] direction LR; int_block_s[block_s+int] --> int_call[get_quack_str <- instance+int] end end i_quack --> quack_15[quack+int <- 15]; duck --> duck_insantiation[#instantiate <- Duck]; r_quack --> call_quack_duck[quack+Duck <- duck]; end Since the end implementation of jinko will have proper paths and canonicalization, we cannot just generate these functions in the outermost scope, or else code like the following would break: func outer () { func generic [ T ]( lhs : T , rhs : T ) -> T { lhs + rhs } a = generic ( 15 , 14 ); b = generic ( 5.4 , 1.2 ); } func outer_again () { func generic [ T ]( lhs : T , rhs : T ) -> T { lhs - rhs } a = generic ( 15 , 14 ); b = generic ( 5.4 , 1.2 ); } As the specialized versions of generic[T] would both get generated in the outer scope, there would be a name collision. With canonicalization, the following would instead happen: func outer :: generic [ int ]( lhs : int , rhs : int ) -> int { lhs + rhs } func outer :: generic [ float ]( lhs : float , rhs : float ) -> float { lhs + rhs } func outer_again :: generic [ int ]( lhs : int , rhs : int ) -> int { lhs - rhs } func outer_again :: generic [ float ]( lhs : float , rhs : float ) -> float { lhs - rhs } func outer () { func outer :: generic [ T ]( lhs : T , rhs : T ) -> T { lhs + rhs } a = outer :: generic ( 15 , 14 ); b = outer :: generic ( 5.4 , 1.2 ); } func outer_again () { func outer_again :: generic [ T ]( lhs : T , rhs : T ) -> T { lhs - rhs } a = outer_again :: generic ( 15 , 14 ); b = outer_again :: generic ( 5.4 , 1.2 ); } Generics resolving flowchart TD; generic_dec -----> add_fn; generic_cal[generic_call] --> create_specialized_fn; create_specialized_fn --> resolve_generic[resolve_generic.with_type_map]; resolve_generic --> typecheck_fn; typecheck_fn --> add_fn; Generics visitor // stdlib/vec.jk type Vec [ T ]( pointer : RawPointer ); func create_vec [ T ]() -> Vec [ T ] { Vec [ T ]( pointer : 0x0 ) } func push [ T ]( v : Vec [ T ], elt : T ) { inner_init [ T ]( v ); inner_grow [ T ]( v , elt ); } // main.jk v = create_vec [ int ](); v . push [ int ]( 14 ); // stdlib/vec.jk type Vec [ T ]( pointer : RawPointer ); struct TypeId { id : Symbol , // T generics : Vec < TypeId > , // [] } // [T -> int] struct TypeId { id : Symbol , // int generics : Vec < TypeId > , // [] } // add_specialized_node(SpecializedNode::Type(new_type)); func create_vec + int () -> Vec + int { // [T -> int] Vec + int ( pointer : RawPointer ( 0x0 )) } func create_vec [ T ]() -> Vec [ T ] { Vec [ T ]( pointer : RawPointer ( 0x0 )) } func push + int ( v : Vec + int , elt : int ) { inner_init + int ( v ); inner_grow + int ( v , elt ); } func push [ T ]( v : Vec [ T ], elt : T ) { inner_init [ T ]( v ); inner_grow [ T ]( v , elt ); } // main.jk v = create_vec [ int ](); // OK v . push [ int ]( 14 ); Generating specialized inner nodes Nodes defined inside other nodes need to be handled as well func id [ T ]( input : T ) -> T { func inner_id [ T ]( input : T ) -> T { input }; inner_id [ T ]( input ) } id [ int ]( 15 ) func id + int ( input : int ) -> int { // Here in expansion phase } func id [ T ]( input : T ) -> T { func inner_id [ T ]( input : T ) -> T { input }; inner_id [ T ]( input ) } id [ int ]( 15 ) At this point in the expansion phase, we are in a resolve-usages phase. Meaning that we are simply trying to replace usages of generic types with their resolved counter points, changing from T to int in that case. However for the function declaration, we need to create a new definition using the resolved type: This is a resolve-expand phase of the expansion. We can maybe simply make it so that having a FunctionDeclaration in a resolve-usages context creates a new function and adds it as a specialized node func inner_id + int ( input : int ) -> int { input } func id + int ( input : int ) -> int { // Remove the declaration node? Just declare it still? inner_id + int ( input ) } func id [ T ]( input : T ) -> T { func inner_id [ T ]( input : T ) -> T { input }; inner_id [ T ]( input ) } id [ int ]( 15 )","title":"Canonicalization and generics in jinko"},{"location":"writeups/2-generics/#canonicalization-and-generics-in-jinko","text":"","title":"Canonicalization and generics in jinko"},{"location":"writeups/2-generics/#rules","text":"Each block is its own subgraph Each line of the graph corresponds to an instruction Each arrow is an assignment statements simply have their return value \"ignored\" in this representation _ -> stmt Function declaration syntax: <func_name> -> [ <arg> [, <arg>]* ] -> <ret_val> examples: println -> s -> , takes_nothing -> -> , return_value -> -> x macro: ( $f_name : ident -> $($arg : ident ), * -> $($ret_type : ident ) ? ) Function call syntax: <func_name> <- [ <arg> [, <arg>]* ] examples: println <- 'hey' , takes_nothing <- , return_value <- macro: ( $f_name : ident <- $($arg : ident ), * )","title":"Rules"},{"location":"writeups/2-generics/#example-graph","text":"func f ( a : int , b : int ) -> int { print ( a ); a + b } flowchart TD; subgraph f[f -> a, b -> x]; direction LR; a --> a_init; b --> b_init; x --> f_block; subgraph f_block[f_block -> block_x] direction LR; _ --> print[print <- a] block_x --> add[add <- a, b] end end","title":"Example graph"},{"location":"writeups/2-generics/#problem","text":"Generating specialized function during generic expansion [1] causes specialized functions to be dropped when exiting the current typechecking scope. Specialized functions (i.e. expanded generics) need to be generated and put in the outermost scopemap in order to not get deleted when exiting the current scope. [1]: A generic function can be declared and will be expanded right after typechecking // Original code func quack [ D ]( instance : D ) -> string { instance . get_quack_str () } i_quack = 15. quack (); type Duck ; fn get_quack_str ( d : Duck ) -> string { \"quack\" } r_quack = Duck . quack (); // after typechecking func quack [ D ]( instance : D ) -> string { instance . get_quack_str () } i_quack = 15. quack (); // 15 <- int // We want quack[int](instance: int) -> string type Duck ; fn get_quack_str ( d : Duck ) -> string { \"quack\" } r_quack = Duck . quack (); // Duck <- Duck // We want quack[Duck](instance: Duck) -> string // specialization/monomorphization func quack [ D ]( instance : D ) -> string { instance . get_quack_str () } func quack + int ( instance : int ) -> string { instance . get_quack_str () } // type error func quack + Duck ( instance : Duck ) -> string { instance . get_quack_str () } // Okay! i_quack = quack [ int ]( 15 ); type Duck ; fn get_quack_str ( d : Duck ) -> string { \"quack\" } r_quack = quack [ Duck ]( Duck ); Sadly, this process happens during typechecking which contains a different scopemap from the execution context. What we can do is return a vector of generated nodes after the typechecking phase and insert those in the execution context. They however need proper canonicalization, which we'll discuss after. flowchart TD; subgraph entry direction LR; subgraph quack_gen[quack+D -> instance -> s]; direction LR; instance --> instance_init; s --> f_block subgraph f_block[quack_block+D -> block_s] direction LR; block_s --> call[get_quack_str <- instance] end end i_quack --> quack_15[quack <- 15]; duck --> duck_insantiation[#instantiate <- Duck]; r_quack --> quack_duck[quack <- duck]; end end result: flowchart TD; classDef specialized fill:#f9f,stroke:#333,stroke-width:4px; class quack_Duck specialized; class quack_int specialized; subgraph entry direction LR; subgraph quack_gen[quack+D -> instance -> s]; direction LR; instance --> instance_init; s --> f_block subgraph f_block[quack_block+D -> block_s] direction LR; block_s --> call[get_quack_str <- instance] end end subgraph quack_Duck[quack+Duck -> instance+Duck -> s+Duck]; direction LR; Duck_instance[instance+Duck] --> Duck_instance_init[instance+Duck_init]; Duck_s[s+Duck] --> q_Duck_block subgraph q_Duck_block[quack_block+Duck -> block_s+Duck] direction LR; Duck_block_s[block_s+Duck] --> Duck_call[get_quack_str <- instance+Duck] end end subgraph quack_int[quack+int -> instance+int -> s+int]; direction LR; int_instance[instance+int] --> int_instance_init[instance+int_init]; int_s[s+int] --> q_int_block subgraph q_int_block[quack_block+int -> block_s+int] direction LR; int_block_s[block_s+int] --> int_call[get_quack_str <- instance+int] end end i_quack --> quack_15[quack+int <- 15]; duck --> duck_insantiation[#instantiate <- Duck]; r_quack --> call_quack_duck[quack+Duck <- duck]; end Since the end implementation of jinko will have proper paths and canonicalization, we cannot just generate these functions in the outermost scope, or else code like the following would break: func outer () { func generic [ T ]( lhs : T , rhs : T ) -> T { lhs + rhs } a = generic ( 15 , 14 ); b = generic ( 5.4 , 1.2 ); } func outer_again () { func generic [ T ]( lhs : T , rhs : T ) -> T { lhs - rhs } a = generic ( 15 , 14 ); b = generic ( 5.4 , 1.2 ); } As the specialized versions of generic[T] would both get generated in the outer scope, there would be a name collision. With canonicalization, the following would instead happen: func outer :: generic [ int ]( lhs : int , rhs : int ) -> int { lhs + rhs } func outer :: generic [ float ]( lhs : float , rhs : float ) -> float { lhs + rhs } func outer_again :: generic [ int ]( lhs : int , rhs : int ) -> int { lhs - rhs } func outer_again :: generic [ float ]( lhs : float , rhs : float ) -> float { lhs - rhs } func outer () { func outer :: generic [ T ]( lhs : T , rhs : T ) -> T { lhs + rhs } a = outer :: generic ( 15 , 14 ); b = outer :: generic ( 5.4 , 1.2 ); } func outer_again () { func outer_again :: generic [ T ]( lhs : T , rhs : T ) -> T { lhs - rhs } a = outer_again :: generic ( 15 , 14 ); b = outer_again :: generic ( 5.4 , 1.2 ); }","title":"Problem"},{"location":"writeups/2-generics/#generics-resolving","text":"flowchart TD; generic_dec -----> add_fn; generic_cal[generic_call] --> create_specialized_fn; create_specialized_fn --> resolve_generic[resolve_generic.with_type_map]; resolve_generic --> typecheck_fn; typecheck_fn --> add_fn;","title":"Generics resolving"},{"location":"writeups/2-generics/#generics-visitor","text":"// stdlib/vec.jk type Vec [ T ]( pointer : RawPointer ); func create_vec [ T ]() -> Vec [ T ] { Vec [ T ]( pointer : 0x0 ) } func push [ T ]( v : Vec [ T ], elt : T ) { inner_init [ T ]( v ); inner_grow [ T ]( v , elt ); } // main.jk v = create_vec [ int ](); v . push [ int ]( 14 ); // stdlib/vec.jk type Vec [ T ]( pointer : RawPointer ); struct TypeId { id : Symbol , // T generics : Vec < TypeId > , // [] } // [T -> int] struct TypeId { id : Symbol , // int generics : Vec < TypeId > , // [] } // add_specialized_node(SpecializedNode::Type(new_type)); func create_vec + int () -> Vec + int { // [T -> int] Vec + int ( pointer : RawPointer ( 0x0 )) } func create_vec [ T ]() -> Vec [ T ] { Vec [ T ]( pointer : RawPointer ( 0x0 )) } func push + int ( v : Vec + int , elt : int ) { inner_init + int ( v ); inner_grow + int ( v , elt ); } func push [ T ]( v : Vec [ T ], elt : T ) { inner_init [ T ]( v ); inner_grow [ T ]( v , elt ); } // main.jk v = create_vec [ int ](); // OK v . push [ int ]( 14 );","title":"Generics visitor"},{"location":"writeups/2-generics/#generating-specialized-inner-nodes","text":"Nodes defined inside other nodes need to be handled as well func id [ T ]( input : T ) -> T { func inner_id [ T ]( input : T ) -> T { input }; inner_id [ T ]( input ) } id [ int ]( 15 ) func id + int ( input : int ) -> int { // Here in expansion phase } func id [ T ]( input : T ) -> T { func inner_id [ T ]( input : T ) -> T { input }; inner_id [ T ]( input ) } id [ int ]( 15 ) At this point in the expansion phase, we are in a resolve-usages phase. Meaning that we are simply trying to replace usages of generic types with their resolved counter points, changing from T to int in that case. However for the function declaration, we need to create a new definition using the resolved type: This is a resolve-expand phase of the expansion. We can maybe simply make it so that having a FunctionDeclaration in a resolve-usages context creates a new function and adds it as a specialized node func inner_id + int ( input : int ) -> int { input } func id + int ( input : int ) -> int { // Remove the declaration node? Just declare it still? inner_id + int ( input ) } func id [ T ]( input : T ) -> T { func inner_id [ T ]( input : T ) -> T { input }; inner_id [ T ]( input ) } id [ int ]( 15 )","title":"Generating specialized inner nodes"},{"location":"writeups/3-multi-types/","text":"Desugaring multi types in jinko type Red ; type Blue ; type Green ( is_light : bool ); type Color ( Red | Green | Blue ); color : Color = Green ( is_light : true ); // can get compiled/lowered to ( color_type_mark , color_value ) = ( 1 , Green ( is_light : true )); // then, when matching on `color` switch color { _ : Red -> {}, _ : Blue -> {}, _ : Green -> {}, } // could get compiled/lowered to switch color_type_mark { 0 : Red -> { /* we use color_value */ }, 1 : Blue -> { /* we use color_value */ }, 2 : Green -> { /* we use color_value */ }, } Likewise for anonymous multi-types: func takes_red_or_blue ( color : Red | Blue , some_arg : int ) { switch color { /* ... */ } } // becomes func takes_red_or_blue ( color_type_mark : int , color_value : Red | Blue , some_arg : int ) { switch color_type_mark { /* ... */ } }","title":"Desugaring multi types in jinko"},{"location":"writeups/3-multi-types/#desugaring-multi-types-in-jinko","text":"type Red ; type Blue ; type Green ( is_light : bool ); type Color ( Red | Green | Blue ); color : Color = Green ( is_light : true ); // can get compiled/lowered to ( color_type_mark , color_value ) = ( 1 , Green ( is_light : true )); // then, when matching on `color` switch color { _ : Red -> {}, _ : Blue -> {}, _ : Green -> {}, } // could get compiled/lowered to switch color_type_mark { 0 : Red -> { /* we use color_value */ }, 1 : Blue -> { /* we use color_value */ }, 2 : Green -> { /* we use color_value */ }, } Likewise for anonymous multi-types: func takes_red_or_blue ( color : Red | Blue , some_arg : int ) { switch color { /* ... */ } } // becomes func takes_red_or_blue ( color_type_mark : int , color_value : Red | Blue , some_arg : int ) { switch color_type_mark { /* ... */ } }","title":"Desugaring multi types in jinko"},{"location":"writeups/4-error-handling-inside-the-interpreter/","text":"Error handling inside jinko's interpreter Since we are designing a programming language, we must take particular attention in reporting the errors that users are encountering. This means delivering clear and beautiful error messages, which is not the point of this write-up, as well as handling their emission properly. Most errors are not fatal to the programmer: We do not want them to stop the flow of typechecking completely and stop the interpreter. Instead, we want to skip over the offending instruction and check the next one. This allows for emitting multiple errors per interpreter invocation, making for a better development experience. However, the Rust way of handling errors is usually to stop the flow of execution if an error arises, propagating it back to the caller using the ? operator. Obviously, this cannot work really well with emitting multiple errors: As soon as one is detected, it will be propagated all the way up to the caller, eventually short-circuiting the main function. To avoid this, we currently store errors inside the various Contexts in the form of an ErrorHandler , which is basically a glorified Vec<jinko::Error> type. jinko::Error s are built using a builder pattern, and then stored in the context's error handler. This causes a lot of code to look like the following: if something_bad () { ctx . error ( Error :: new ( ErrKind :: TypeChecker ) . with_msg ( \"typechecking error!\" ) . with_loc ( self . location ()) . with_hint ( Error :: hint () . with_loc ( dec . location ()) . with_msg ( \"something helpful\" ))); return ; // return nothing, since the function does not return a Result: Errors are // kept in the context } This produces a lot of noise, and makes for nasty code sprinkled in a lot of places in the interpreter. I believe we should be able to clean that up by categorizing jinko nodes as either \"Aggregation sites\" or \"Emission sites\". Ideally, individual instructions can simply return an error: If they are invalid, there's a good chance that they do not want to keep typechecking and instead want to return early. Let's take the following jinko instruction func add ( lhs : int , rhs : int ) -> int { lhs + rhs } a = 15. add ( 14 ). add ( \"5\" ). add ( 27 ) // ^ type error In the above example, there's a type error: We're trying to give a string to a function that only takes two integers as arguments. Why should we go further down the line and try to type-check the third call to add? Since the second one is inerently incorrect, there is absolutely nothing to be gained from analyzing the third one. The user might have tried to give an integer instead, and will change \"5\" to 5 , or they might have wanted to instead call an entirely different function. Hell, maybe they forgot a call to parse[int]() in the middle. That's a lot of possibilities, which we cannot reasonnably account for. Instead, the second method call in there should return an error, which will be propagated by the first method call back to the assignment expression, which should then propagate it as well. Likewise, if we turned the above assignment in an arithmetic operation like so a = 15. add ( 14 ). add ( \"5\" ). add ( 27 ) * 'k' There'd be no point in typechecking that the operation can actually happen. The left hand side of the operator is in an error state, so there is absolutely no way that this code will ever be valid. We will thus refer to the assignment expression, the method call or the binary operation as an Emission Sites . When going through the various static analysis passes, they cannot accumulate errors: They should just propagate them when they happen. Binary operations are a bit special in that they contain two expressions to typecheck, so we might as well go and type check the right hand of the operation for more feedback to the user. This is opposed to Aggregation Sites , such as blocks of code: In a block, multiple separate instructions need to be checked for errors. This causes the user to want multiple errors to be reported: { i1 = 15. add ( '5' ); i2 = println ( not_a_string ); i3 = add ( invalid , amount , of_args ); } These 3 instructions have completely separate error messages, which the user would want to be reported all at once. i1 should emit an error regarding the type of the argument given to add() , just like i2 for a different function and different type. Finally, i3 should error out because of the invalid amount of arguments given to the add() function. A block is thus an aggregation site. Upon encountering an error when checking one of its instruction, it should store it, but still check the following instruction it contains before returning in an error state. Since blocks are the base upon which the entirety of jinko is built (they are present in function definitions, loops, if-else blocks...), aggregating errors only in a few places should easily offer a lot of useful feedback to the user while limiting noise in the interpreter's code.","title":"Error handling inside jinko's interpreter"},{"location":"writeups/4-error-handling-inside-the-interpreter/#error-handling-inside-jinkos-interpreter","text":"Since we are designing a programming language, we must take particular attention in reporting the errors that users are encountering. This means delivering clear and beautiful error messages, which is not the point of this write-up, as well as handling their emission properly. Most errors are not fatal to the programmer: We do not want them to stop the flow of typechecking completely and stop the interpreter. Instead, we want to skip over the offending instruction and check the next one. This allows for emitting multiple errors per interpreter invocation, making for a better development experience. However, the Rust way of handling errors is usually to stop the flow of execution if an error arises, propagating it back to the caller using the ? operator. Obviously, this cannot work really well with emitting multiple errors: As soon as one is detected, it will be propagated all the way up to the caller, eventually short-circuiting the main function. To avoid this, we currently store errors inside the various Contexts in the form of an ErrorHandler , which is basically a glorified Vec<jinko::Error> type. jinko::Error s are built using a builder pattern, and then stored in the context's error handler. This causes a lot of code to look like the following: if something_bad () { ctx . error ( Error :: new ( ErrKind :: TypeChecker ) . with_msg ( \"typechecking error!\" ) . with_loc ( self . location ()) . with_hint ( Error :: hint () . with_loc ( dec . location ()) . with_msg ( \"something helpful\" ))); return ; // return nothing, since the function does not return a Result: Errors are // kept in the context } This produces a lot of noise, and makes for nasty code sprinkled in a lot of places in the interpreter. I believe we should be able to clean that up by categorizing jinko nodes as either \"Aggregation sites\" or \"Emission sites\". Ideally, individual instructions can simply return an error: If they are invalid, there's a good chance that they do not want to keep typechecking and instead want to return early. Let's take the following jinko instruction func add ( lhs : int , rhs : int ) -> int { lhs + rhs } a = 15. add ( 14 ). add ( \"5\" ). add ( 27 ) // ^ type error In the above example, there's a type error: We're trying to give a string to a function that only takes two integers as arguments. Why should we go further down the line and try to type-check the third call to add? Since the second one is inerently incorrect, there is absolutely nothing to be gained from analyzing the third one. The user might have tried to give an integer instead, and will change \"5\" to 5 , or they might have wanted to instead call an entirely different function. Hell, maybe they forgot a call to parse[int]() in the middle. That's a lot of possibilities, which we cannot reasonnably account for. Instead, the second method call in there should return an error, which will be propagated by the first method call back to the assignment expression, which should then propagate it as well. Likewise, if we turned the above assignment in an arithmetic operation like so a = 15. add ( 14 ). add ( \"5\" ). add ( 27 ) * 'k' There'd be no point in typechecking that the operation can actually happen. The left hand side of the operator is in an error state, so there is absolutely no way that this code will ever be valid. We will thus refer to the assignment expression, the method call or the binary operation as an Emission Sites . When going through the various static analysis passes, they cannot accumulate errors: They should just propagate them when they happen. Binary operations are a bit special in that they contain two expressions to typecheck, so we might as well go and type check the right hand of the operation for more feedback to the user. This is opposed to Aggregation Sites , such as blocks of code: In a block, multiple separate instructions need to be checked for errors. This causes the user to want multiple errors to be reported: { i1 = 15. add ( '5' ); i2 = println ( not_a_string ); i3 = add ( invalid , amount , of_args ); } These 3 instructions have completely separate error messages, which the user would want to be reported all at once. i1 should emit an error regarding the type of the argument given to add() , just like i2 for a different function and different type. Finally, i3 should error out because of the invalid amount of arguments given to the add() function. A block is thus an aggregation site. Upon encountering an error when checking one of its instruction, it should store it, but still check the following instruction it contains before returning in an error state. Since blocks are the base upon which the entirety of jinko is built (they are present in function definitions, loops, if-else blocks...), aggregating errors only in a few places should easily offer a lot of useful feedback to the user while limiting noise in the interpreter's code.","title":"Error handling inside jinko's interpreter"}]}